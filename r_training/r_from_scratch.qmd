---
title: "R from scratch"
date: 2024-09-24
execute: 
  echo: true
  eval: true
  freeze: auto
  output: "markup"
categories: [R, beginner]
editor_options: 
  chunk_output_type: console
---

```{r}
#| echo: false
#| results: asis
#| fig-align: left
#| fig-height: 0.6
#| fig-width: 3

source(here::here("R/feed_block.R"))
feed_block("R from scratch")

```

# Getting started

-   you'll need some kind of R setup for this training
    -   if you already have some type of R installation available (PHS workbench, Rstudio desktop etc) please feel free to use that
    -   otherwise, create a free account on [posit.cloud](https://posit.cloud/ "https://posit.cloud/")
-   Then confirm that you're able to log-in to that account using the device and the network connection that you're going to be using during the training session. Of note, some board VPNs (PHS, Lothian, couple of others) seem to cause trouble, and it can take a bit of time to work out fixes and workarounds.
-   Once logged in, please attempt a 2 minute test (below) so that we can be sure everything will be in working order before the first training session:

:::{.callout-note collapse=true appearance='default' icon=true}
## Testing your Posit Cloud
1. sign in to your account at <https://posit.cloud/>
1. create a New RStudio Project from the big blue button</br> ![create a New RStudio Project](images/clipboard-1870431838.png)
1. after 30 seconds or so you should have a new R project open in front of you</br>![new R project](images/clipboard-3686794244.png)
1. in the console - the bottom-left part of the window with all the text in - please type `demo(image)` at the `>` prompt and press enter
1. keep pressing enter until you see graphs start appearing (2-3 times should do it)</br>![demo plots](images/clipboard-984098222.png)
:::



::: {.panel-tabset}


# Session 1: "hello world"

## hello world

-   R has a terminal where you can write code, and R will run it for you and show you the results
-   we'll start with a string, which is how we keep words in R code (single or double quotes, your choice)
-   type a string in the terminal

```{r}
"hello world"
```
</br> !["hello world" in the terminal](images/clipboard-1008380297.png)

-   but we usually write R in script files
-   start a new R script</br>![New R script](images/clipboard-4056129341.png)
-   now press `Ctrl` + `Enter` to run your script

```{r}
"hello world"
```

-   (for the coders, R has implicit print)

```{r}
# variable
# assignment operator
hw <- "hello world"
hw
```

```{r}
# R is case sensitive
# R runs from top to bottom - you can't use an object until you've made it
try(HW) # a way of running broken code and capturing the error messages it provokes
HW <- "HELLO WORLD"
HW
```

## functions

```{r}
# print function
# variables persist
print(hw)
```

```{r}
#| eval: false

# help for all functions
?print
```

```{r}
# look at the help and try to make substr work to pull out "hello"
# arguments
substr(hw, 1, 5)
```

```{r}
# return value
# assign out of functions
hi <- substr(hw, 1, 5)
```

```{r}
# vectors
# combine
c(hw, hw)
length(c(hw, hw))
```

```{r}
# most functions are vectorised
substr(c(hw, hw), 1, 5)
hh <- substr(c(hw, hw), 1, 5)
```

```{r}
# especially nice for maths stuff
# logic
c(4,3,7,55) * 2
c(4,3,7,55) > 10
```

```{r}
# indexing
# range operator
hh[1]
c("this", "is", "another", "indexing", "example")[3]
c("this", "is", "another", "indexing", "example")[3:4]
```

```{r}
#length
# typeof
length(hh)
typeof(hh)
```

## data types and classes

```{r}
# vectors
# homogenous - only one kind of thing per vector
typeof("this is a string")
typeof(1L)
typeof(1)
typeof(TRUE)
```

```{r}
# factors - the odd one
# mainly a way of storing categorical data, especially when you need it in non-alphabetical order
factor(c("thing", "string", "wing", "bling")) # alphabetical
ing_things <- factor(c("thing", "string", "wing", "bling"), levels = c("wing", "bling", "string", "thing")) # alphabetical
ing_things
ing_things[2]
```

```{r}
# the list = a vector of vectors
# ragged - can store different kinds of values together
list(hh, hi, hw, ing_things)

# names
named_list <- list("hw" = hh, 
                   "hi" = hi, 
                   "hw" = hw, 
                   "silly_name" = ing_things)
named_list
```

```{r}
# different indexing required for lists
class(named_list[4]) #gets you a smaller list

# two easy ways of getting vectors out of lists
named_list$silly_name
named_list[[4]]

# and you can flatten a list into a vector
unlist(named_list)
```


# Session 2: core function toolkit

## session 1 reminders

* console vs script (`Ctrl` + `âŽ`)
* assign values to variables with `<-`
* vectors = simplest R data structure (like an ordered group)
* functions = R verbs that:
  * are case-sensitive, whitespace-insensitive
  * have arguments (roughly = options)
  * return results
  * are usually vectorised (so can be used over all members of a vector)

### make some play data

```{r}
a <- 2
numbers <- c(3,6,5,4,3)
string <- "just a string"
longer_string <- c("this", "is", "a", "length", "seven", "character", "vector")
```

## core numeric operators and functions

### arithmetic
```{r}
1 + 3
numbers * 5 # they're vectorised
4 / 3
5 - numbers
8 ^ 0.5
```


### range operator

The range operator is an easy way of making integer sequences:

```{r}
1:4
5:2
```

There's always a fancier way too:

```{r}
seq(1,3,0.2)
```

### equals/inequality

Really important for lots of programming things

```{r}
a <- 2
a == 2
a < 3
a >= 2
a != 2
numbers > 3
numbers[numbers > 3] # filtering with equalities/inequalities
```

### fancy operator bits
```{r}
5 %% 3 # remainder / modulo for remainder-after-division
5 %/% 3 # integer division
```

### core numeric functions

Note that most of these functions are vectorised, but will require you to use `c()` if you want to supply your values directly (i.e. if you don't want to make a variable containing your values first). `sum()` is a rare exception:

```{r}
sum(1,5,10) # works okay
sum(c(1,5,10)) # but this works fine too, and is easy
mean(c(1,5,10)) # and is the general way you'll need to work if you're supplying values directly to the function
```

```{r}
sqrt(a) # square root
sum(numbers)
cumsum(numbers)
sqrt(numbers) # square roots
mean(numbers) 
median(numbers)
min(numbers)
max(numbers)
```

For odd reasons, there's no built-in function to find the statistical mode of some numbers. It can be done, but the code is ugly (and exactly the sort of thing we'd usually avoid in beginner's sessions). Included here for interest only:

```{r}
# mode
as.numeric(names(sort(-table(numbers)))[1])
```

There are also a few other fairly basic functions that you might find helpful:

```{r}
sd(numbers) # standard deviation
range(numbers) # min and max in one
summary(numbers) # good for rapid numeric summaries
table(numbers) # good for finding out what you've got in more complicated vectors
```


## interlude: joining code together

There are three main ways of doing this. Traditionally, you'd bracket together several functions, and read from the inside out. Fastest to write, hardest to read and fix:

```{r}
round(sqrt(c(1,5,10)))
```

or you can make intervening variables. Messy, but good if you need to be extra careful:
```{r}
n <- c(1,5,10)
o <- sqrt(n)
p <- round(o)
p
```

or, probably the best way, pipe the code together. `Ctrl` + `Shift` + `m` will give you a pipe symbol:

```{r}
c(1,5,10) |>
  sqrt() |>
  round()
```

Note that the pipe method doesn't automatically save your output. You'll need to assign with `<-` to do that:

```{r}
temp <- c(1,5,10) |>
  sqrt() |>
  round()

temp
```

## basic string functions

```{r}
tolower(hw)
toupper(hw)
tolower(longer_string)
toupper(longer_string)

paste(hw, hw)
paste(string, "ed instrument")
paste0("question ", numbers)

rep(hw, 10)
```

## a few more interesting string functions

```{r}
strsplit(hw, " ") # split a string into pieces and get a list back

strsplit(hw, " ") |> # split and unlist back to vector
  unlist()

grep("seven", longer_string) # tell me where in a vector a search term is found

grepl("seven", longer_string) # tell me if a vector contains a search term

sort(longer_string) # into alphabetical order

table(longer_string) # as with numbers
```

# Session 3: functions, loops, and flow

Don't repeat your code. Long code is hard to read and understand. Three basic design patterns: the function, the loop, the if/else.

## write a function

```{r}
# basic function syntax
# need to run the definition before calling it

function_name <- function(argument){
  # some code doing something to the argument
  argument + 4 # the function will return the last value it produces
}

function_name(3)

```

```{r}
# challenge - I'm bored of writing na.rm = TRUE. Could you make mean() automatically ignore the missing values?

new_mean <- function(x){
  mean(x, na.rm = TRUE)
}

new_mean(c(1,4,2,4,NA))
```

```{r}
# arguments and defaults
# simple function syntax without {}

multo <- function(n1, n2 = 7) n1 * n2

multo(3)  
multo(3, 6)  
```

```{r}
# anonymous function syntax is useful, but way too evil for a beginner's course

(\(x) x^2)(5)
(\(x, y) x^y)(5,3)
```

## write a loop

```{r}
# basic syntax 
for(i in 1:5){
  print(i)
}
```

```{r}
# seq_along as a sensible safe way to work with vectors
for(i in seq_along(numbers)){ # seq_along converts a vector into sequential integers 1,2,3,4... up to the length of the vector
  print(i)
}
```

```{r}
# indexing is the key to working with vectors inside loops
for(i in seq_along(numbers)){
  print(numbers[i]) # with indexing
}
```

```{r}
# need to create output first, then collect

loop_output <- vector(mode = "numeric", length = length(numbers))

for(i in seq_along(numbers)){
  loop_output[i] <- numbers[i] * 9 # insert each bit of output into the right place in the output vector
}

loop_output

```

## write an if/else

```{r}
# basic syntax
a <- 3

if(a == 3){
  "a is three"
} else {
  "nope"
}
```

```{r}
# even easier if your condition is logical
c <- TRUE

if(c){
  "c is true"
} else {
  "nope"
}
```

```{r}
# combine conditions
b <- 2

if(a == 3 | b == 3){
  "a and/or b are three"
} else {
  "nope"
}

if(a == 3 & b == 3){
  "a and/or b are three"
} else {
  "nope"
}

```

```{r}
#| eval: false

d <- c(4,3)

if(d == 3){
  "if/else isn't vectorised"
} else {
  "so this won't work"
}
```

```{r}
# use the ifelse type if you need vectorised if/else
d <- c(4,3)

ifelse(d == 3, "...and we'll get this one second", "the first item is false, so we'll get this first")
```



# Session 4: packages and dplyr

We can bring in external code to help us with R. That external code is known as a package. There are thousands of packages in current use, as the [relevant pages on CRAN will tell you](https://cran.r-project.org/web/packages/available_packages_by_date.html).

## penguins

We need to install packages before we can use them. That only needs to be done once for your R setup. To illustrate, let's install a package, called [palmerpenguins](https://allisonhorst.github.io/palmerpenguins/), which contains some interesting data:

```{r}
#| eval: false
install.packages("palmerpenguins")
```

Once that package is installed, we can use the data (and functions) it contains by attaching them to our current script:

```{r}
library(palmerpenguins)
```

Once we've done that, we'll have several new items available to use. The most important here is the main `penguins` dataset:

```{r}
penguins
```

That's tabular data - so formed into rows and columns, rectangular (so all columns the same lengths etc), and with each column containing only one type of data. Tabular data is probably the most widely used type of data in R. That means that there are lots of tools for working with it. Some basic examples:

```{r}
nrow(penguins)
ncol(penguins)
head(penguins)
names(penguins)
```

## dplyr

As well as those base-R functions, there are also many packages for working with tabular data. Probably the best-known package is [dplyr](https://dplyr.tidyverse.org/), which we install and attach in the same way as `palmerpenguins`:


```{r}
#| eval: false
install.packages("dplyr")
```

```{r}
library(dplyr)
```

The reason that `dplyr` is so popular is that some of the base-R ways of working with tabular data are a bit messy and hard to read:

```{r}
penguins$species[1:4] # just to show the first few
penguins[["island"]][1:4] # just the first few, again
```

dplyr generally produces much easier-to-read code, especially when using the pipe to bring together lines of code:

```{r}
penguins |>
  select(island) # pick out a column by providing a column name

penguins |>
  select(-island) # remove a column

penguins |>
  select(species, flipper_length_mm, island) # select and re-order columns

penguins |>
  select(home_island = island) # select and rename
```

A note here: the `penguins` object that we're working with is technically called a tibble. `dplyr` is specifically adapted to work with tibbles, and many of the functions won't work properly on other kinds of data structure. The main idea underlying `dplyr` is that the many functions it contains should all work consistently, and work well together. So once you've got the hang of `select` there's not much new to say about `filter`, which picks rows based on their values: 

```{r}
penguins |>
  filter(species == "Adelie") # find some rows about Adelie penguins

penguins |>
  filter(bill_length_mm > 55) # find the big bills

penguins |>
  filter(is.na(bill_length_mm)) # find missing data
```

And `mutate` - which makes new columns - will work in the same way:

```{r}
penguins |>
  mutate(new_col = 11) |> # every row the same
  select(species, new_col) # so that we can see the new values in the preview

penguins |>
  mutate(bill_vol = bill_length_mm * bill_depth_mm^2) |> # some calculation
  select(species, bill_vol)

penguins |>
  mutate(label = paste("From", island, "island, a penguin of the species", species)) |>
  select(label, body_mass_g) # mutate and then select. You can use your new columns immediately.
```

As before, we need to assign with `<-` to save our changes. Let's add the `bill_vol column` to the data now
```{r}
penguins_vol <- penguins |>
  mutate(bill_vol = bill_length_mm * bill_depth_mm^2)
```

`arrange` sorts columns:
```{r}
penguins_vol |>
  arrange(bill_vol)
```

The nice thing about dplyr is that there are several other packages which work in similar ways. This package ecosystem gets called [the tidyverse](https://www.tidyverse.org/), and is extremely widely used to do data science work in R. A close relative of `dplyr` is the `readr` package, which reads in data to R and makes it into tibbles:

```{r}
#| eval: false
install.packages("readr")
```
```{r}
library(readr)

penguins_raw <- read_csv("https://raw.githubusercontent.com/allisonhorst/palmerpenguins/main/inst/extdata/penguins_raw.csv")

```


::: 
<!--  the main tabset, so leave well alone and work within please -->


