---
title: Data masking in R
date: 2025-08-05
execute: 
  echo: true
  eval: true
output: markup
categories: [R, intermediate, functions, debugging]
editor_options: 
  chunk_output_type: console
---

::: {.callout-note collapse="false" appearance="default" icon="true"}
## Session materials

[Data masking cheatsheet {{< iconify ph:file-pdf size=2x >}}](src/te_cheat_sheet.pdf)

:::


```{r}
library(NHSRdatasets)
library(dplyr)
library(purrr)
```


## Introduction

More so than in other programming languages, R functions bias towards helping the user do common tasks easily. One excellent example is the way that tidyverse functions (like dplyr) make assumptions about what users mean when they refer to variables. As an example, if you want to select a column in base R you'd use a quoted column name in single brackets:

```{r}
stranded_data["age"]
```

Doing that in the tidyverse is easier: use an unquoted column name inside `select`:


```{r}
stranded_data |> 
  select(age) 
```

That's conceptually helpful because we're used to referring to ordinary R objects using unquoted variable names. When we specify the age column in this select function, we don't need to tell R that we specifically mean the age column in the `stranded_data` tibble. That's very helpful, because it saves us having to specify that we want to refer to a specific column in a specific tibble each time we write a line of dplyr. Even if we create another tibble that also has an age column...

```{r}
new_stranded_data <- stranded_data |>
  select(stranded.label, age)
```

... we can still just refer to the age column of the original `stranded_data` without any risk of confusion. This simplification - which we'll call **data masking** - is a great advantage of using the pipe, and most of the time data masking just works without giving rise to any problems at all. For example, we can write a vector of column names, and then pass it to `select()`, and R will figure out that we want to use those names as column names without any extra effort on our part:

```{r}
my_cols <- c("age")

stranded_data |>
  select(any_of(my_cols)) # need to use a helper function like any_of since dplyr 1.1.0

```

However, when that data masking goes wrong it can be very challenging to fix. To demonstrate, let's start taking the column-selecting code snippets above, and translating them into functions. Base-R first:

```{r}
column_pick_base <- function(col){
  stranded_data[col]
}
column_pick_base("age")
```

That's simple - we pass a quoted column name to the function, and it returns us the relevant column of data. But if we do the apparently-simple translation to use `select`, things start going wrong:

```{r}
column_pick_tidy <- function(col){
  stranded_data |>
    select(col)
}
```

That works almost as expected if we pass a quoted column name:

```{r}
column_pick_tidy("age")
```

Okay, so we get a deprecated warning to the effect that selecting functions expect unquoted column names. So let's update the function call to do that now:

```{r}
try(column_pick_tidy(age))
```

Uh-oh. This has gone wrong. Unfortunately, to explain why it's gone wrong, we're going to need to think about how data masking really works. We shouldn't try to use the non-standard quoted column ["kludge"](https://en.wiktionary.org/wiki/kludge#English) as that will complicate e.g. using our new function in another function. A stronger approach is to adjust our function code in the first place, so that we don't have to call our function in a non-standard way (why write *age* in some functions, but *"age"* in others to refer to the same thing).

In this section, we'll give a bit of helpful theoretical background about data masking. We'll then go on to look at four ways of resolving some of the difficulties that data masking can cause.

## Background

The [rlang page on data-masking](https://rlang.r-lib.org/reference/topic-data-mask.html) is very helpful here in setting out a key distinction between kinds of variables that we've previously been using synonymously:

+ env-variables (things you create with assignment)
+ data-variables (e.g. imported data in a tibble)

For beginners, this distinction is not that important, particularly because tidyverse functions do lots of helpful blurring between these different types of variable. Note that many base R functions do often require the user to bear this distinction in mind. For instance, in base R you would specify a data variable differently from an environment variable:

```{r eval=F}
mtcars$cyl      # a data variable
cyl <- c(4,6,8) # an environment variable
```

Whereas in tidyverse, you can:

```{r eval=F}
mtcars |>
  select(cyl) # specifying a data variable like an environment variable inside select
```

Most of the time, data masking doesn't cause any problems. However, when you start wanting to include tidyverse functions inside other functions - say, if you're trying to `purrrr` something - that blurring raises a problem. We won't give much of an explanation as to the reasons for this, although do read [this introduction to the topic](https://rlang.r-lib.org/reference/topic-data-mask.html) and [this more detailed account](https://rlang.r-lib.org/reference/topic-data-mask-ambiguity.html) if you are interested in the technical aspects. Here, we'll concentrate on four strategies for resolving these kind of data masking problems. These strategies are:

```{r echo=F}
tribble(
  ~Problem, ~Solution,
  "data-variable in a function argument", "**embracing** with `{{var}}`",
  "env-variable in a vector", "`.data[[var]]` and `.env[[var]]` **pronouns**", 
  "variables in output", "**injection** with **`:=`**",
  "complex cases", "**quasiquotation** with the injection operator `!!`"
) |> 
  knitr::kable()

```


## Embracing

Slightly confusingly, this practice is also referred to [as *tunneling* data variables](https://www.tidyverse.org/blog/2020/02/glue-strings-and-tidy-eval/)

If you want to use a data variable in the argument of a function, you need to ``{{embrace}}`` the argument. Let's add some `{{}}` to our earlier function:

```{r}
column_pick_curly <- function(col){
  stranded_data |>
    select({{col}})
}

column_pick_curly(age)
```

## Pronouns

If you want to use quoted strings to select columns, use **pronouns**:

```{r}
column_pick_pronouns <- function(col){
  stranded_data |>
    select(.data[[col]])
}

column_pick_curly("age")
```

For completeness, we can also play with the `.env` pronoun, which allows us to explicitly refer to an object in the environment. Let's do something horrible, and create an `age` variable in the global environment:

```{r}
age <- 50

column_pick_env <- function(col){
  stranded_data |>
    filter(.data[[col]] > .env[[col]]) 
}

column_pick_env("age")

```

Okay, like so much in this session this is hardly best practice, but if you do ever need to make 100% super-safety-sure that you're referring to unfortunately-named data/env variables, this is probably the least-worst way of working.

## Injection

`:=` lets you inject variables into your output. Yes, this is what the tidyverse people really call it, and no, this isn't a very helpful bit of terminology for the rest of us. Say you want to supply an unquoted column name, and return a renamed selection: 

```{r}
column_pick_rename <- function(col){
  stranded_data |>
    select("new_{{col}}" := {{col}}) 
}

column_pick_rename(age)

```

There's a bit going on here. First, replacing `=` with `:=` injects the supplied column name. Then the new column name is created using `glue()` syntax. `glue()` is a neat replacement for base-R tools like `paste0()`. Empirically, though, a quoted string with `{{}}` containing the function argument will do the work for you.

`:=` is borrowed from mathematics, and is used when defining something new, which is the apparent logic behind its use here. If you try and use `=` in this context, it'll fail because of the consistency checks that tidyverse functions use to check that all's okay with newly-defined names.

## Quasiquotation

A lot of this messing around is effectively concerned with switching between quoted- and unquoted-versions of column names. Quasiquotation is the fancy-sounding name for that messing around, and the tools required to do so:

> Quasiquotation is the combination of quoting an expression while allowing immediate evaluation (unquoting) of part of that expression. ([rlang quasiquotation manual page](https://www.rdocumentation.org/packages/rlang/versions/0.2.1/topics/quasiquotation))

To give the simplest possible example, `!!` gives a generic way of unquoting an argument:

```{r}
quoted_variable <- "age_from_var"

stranded_data |> 
  rename("{quoted_variable}" := age) |>
  select(!!quoted_variable)
```


