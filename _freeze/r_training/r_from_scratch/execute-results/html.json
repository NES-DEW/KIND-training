{
  "hash": "90c464915c65fe14921e870f35ff056e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R from scratch\"\ndate: 2024-09-03\nexecute: \n  echo: true\n  eval: true\n  freeze: auto\n  output: \"markup\"\ncategories: [R, beginner]\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell layout-align=\"left\"}\n  \n## Previous attendees have said...  \n  \n- 36 previous attendees have left feedback\n- 100% would recommend this session to a colleague\n- 94% said that this session was pitched correctly  \n\n  \n![](r_from_scratch_files/figure-html/unnamed-chunk-1-1.png){fig-align='left' width=288}  \n  \n:::{.callout-note}  \n### Three random comments from previous attendees  \n- Base R broken down into easy to understand language so it's not confusing.  As an R beginner I found this very helpful and look forward to the next session to build on my knowledge and understanding.  I work within Data Management where R hasn't been geared towards with basic training, as the training available is usually geared towards Analytical staff who have more knowledge of R, and with R becoming utilised more within Data Management these kind of sessions are essential allowing for personal development to help with your workstreams.\n- Informative, well organised, informal. Comfortable learning environment.\n- A well paced and gentle introduction to R. Well delivered by a very approachable host.\n  \n:::  \n:::\n\n\n# Getting started\n\n-   you'll need some kind of R setup for this training\n    -   if you already have some type of R installation available (PHS workbench, Rstudio desktop etc) please feel free to use that\n    -   otherwise, create a free account on [posit.cloud](https://posit.cloud/ \"https://posit.cloud/\")\n-   Then confirm that you're able to log-in to that account using the device and the network connection that you're going to be using during the training session. Of note, some board VPNs (PHS, Lothian, couple of others) seem to cause trouble, and it can take a bit of time to work out fixes and workarounds.\n-   Once logged in, please attempt a 2 minute test (below) so that we can be sure everything will be in working order before the first training session:\n\n:::{.callout-note collapse=true appearance='default' icon=true}\n## Testing your Posit Cloud\n1. sign in to your account at <https://posit.cloud/>\n1. create a New RStudio Project from the big blue button</br> ![create a New RStudio Project](images/clipboard-1870431838.png)\n1. after 30 seconds or so you should have a new R project open in front of you</br>![new R project](images/clipboard-3686794244.png)\n1. in the console - the bottom-left part of the window with all the text in - please type `demo(image)` at the `>` prompt and press enter\n1. keep pressing enter until you see graphs start appearing (2-3 times should do it)</br>![demo plots](images/clipboard-984098222.png)\n:::\n\n\n\n::: {.panel-tabset}\n\n\n# Session 1: \"hello world\"\n\n## hello world\n\n-   R has a terminal where you can write code, and R will run it for you and show you the results\n-   we'll start with a string, which is how we keep words in R code (single or double quotes, your choice)\n-   type a string in the terminal\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"hello world\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world\"\n```\n\n\n:::\n:::\n\n</br> ![\"hello world\" in the terminal](images/clipboard-1008380297.png)\n\n-   but we usually write R in script files\n-   start a new R script</br>![New R script](images/clipboard-4056129341.png)\n-   now press `Ctrl` + `Enter` to run your script\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"hello world\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world\"\n```\n\n\n:::\n:::\n\n\n-   (for the coders, R has implicit print)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# variable\n# assignment operator\nhw <- \"hello world\"\nhw\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# R is case sensitive\n# R runs from top to bottom - you can't use an object until you've made it\ntry(HW) # a way of running broken code and capturing the error messages it provokes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in eval(expr, envir, enclos) : object 'HW' not found\n```\n\n\n:::\n\n```{.r .cell-code}\nHW <- \"HELLO WORLD\"\nHW\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"HELLO WORLD\"\n```\n\n\n:::\n:::\n\n\n## functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# print function\n# variables persist\nprint(hw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# help for all functions\n?print\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# look at the help and try to make substr work to pull out \"hello\"\n# arguments\nsubstr(hw, 1, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# return value\n# assign out of functions\nhi <- substr(hw, 1, 5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# vectors\n# combine\nc(hw, hw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world\" \"hello world\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(c(hw, hw))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# most functions are vectorised\nsubstr(c(hw, hw), 1, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello\" \"hello\"\n```\n\n\n:::\n\n```{.r .cell-code}\nhh <- substr(c(hw, hw), 1, 5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# especially nice for maths stuff\n# logic\nc(4,3,7,55) * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   8   6  14 110\n```\n\n\n:::\n\n```{.r .cell-code}\nc(4,3,7,55) > 10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE  TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# indexing\n# range operator\nhh[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc(\"this\", \"is\", \"another\", \"indexing\", \"example\")[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"another\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc(\"this\", \"is\", \"another\", \"indexing\", \"example\")[3:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"another\"  \"indexing\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#length\n# typeof\nlength(hh)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(hh)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n## data types and classes\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# vectors\n# homogenous - only one kind of thing per vector\ntypeof(\"this is a string\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# factors - the odd one\n# mainly a way of storing categorical data, especially when you need it in non-alphabetical order\nfactor(c(\"thing\", \"string\", \"wing\", \"bling\")) # alphabetical\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] thing  string wing   bling \nLevels: bling string thing wing\n```\n\n\n:::\n\n```{.r .cell-code}\ning_things <- factor(c(\"thing\", \"string\", \"wing\", \"bling\"), levels = c(\"wing\", \"bling\", \"string\", \"thing\")) # alphabetical\ning_things\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] thing  string wing   bling \nLevels: wing bling string thing\n```\n\n\n:::\n\n```{.r .cell-code}\ning_things[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] string\nLevels: wing bling string thing\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# the list = a vector of vectors\n# ragged - can store different kinds of values together\nlist(hh, hi, hw, ing_things)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"hello\" \"hello\"\n\n[[2]]\n[1] \"hello\"\n\n[[3]]\n[1] \"hello world\"\n\n[[4]]\n[1] thing  string wing   bling \nLevels: wing bling string thing\n```\n\n\n:::\n\n```{.r .cell-code}\n# names\nnamed_list <- list(\"hw\" = hh, \n                   \"hi\" = hi, \n                   \"hw\" = hw, \n                   \"silly_name\" = ing_things)\nnamed_list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$hw\n[1] \"hello\" \"hello\"\n\n$hi\n[1] \"hello\"\n\n$hw\n[1] \"hello world\"\n\n$silly_name\n[1] thing  string wing   bling \nLevels: wing bling string thing\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# different indexing required for lists\nclass(named_list[4]) #gets you a smaller list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# two easy ways of getting vectors out of lists\nnamed_list$silly_name\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] thing  string wing   bling \nLevels: wing bling string thing\n```\n\n\n:::\n\n```{.r .cell-code}\nnamed_list[[4]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] thing  string wing   bling \nLevels: wing bling string thing\n```\n\n\n:::\n\n```{.r .cell-code}\n# and you can flatten a list into a vector\nunlist(named_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          hw1           hw2            hi            hw   silly_name1 \n      \"hello\"       \"hello\"       \"hello\" \"hello world\"           \"4\" \n  silly_name2   silly_name3   silly_name4 \n          \"3\"           \"1\"           \"2\" \n```\n\n\n:::\n:::\n\n\n\n# Session 2: core function toolkit\n\n## session 1 reminders\n\n* console vs script (`Ctrl` + `âŽ`)\n* assign values to variables with `<-`\n* vectors = simplest R data structure (like an ordered group)\n* functions = R verbs that:\n  * are case-sensitive, whitespace-insensitive\n  * have arguments (roughly = options)\n  * return results\n  * are usually vectorised (so can be used over all members of a vector)\n\n### make some play data\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 2\nnumbers <- c(3,6,5,4,3)\nstring <- \"just a string\"\nlonger_string <- c(\"this\", \"is\", \"a\", \"length\", \"seven\", \"character\", \"vector\")\n```\n:::\n\n\n## core numeric operators and functions\n\n### arithmetic\n\n::: {.cell}\n\n```{.r .cell-code}\n1 + 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nnumbers * 5 # they're vectorised\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15 30 25 20 15\n```\n\n\n:::\n\n```{.r .cell-code}\n4 / 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.333333\n```\n\n\n:::\n\n```{.r .cell-code}\n5 - numbers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2 -1  0  1  2\n```\n\n\n:::\n\n```{.r .cell-code}\n8 ^ 0.5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.828427\n```\n\n\n:::\n:::\n\n\n\n### range operator\n\nThe range operator is an easy way of making integer sequences:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\n5:2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 4 3 2\n```\n\n\n:::\n:::\n\n\nThere's always a fancier way too:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(1,3,0.2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0\n```\n\n\n:::\n:::\n\n\n### equals/inequality\n\nReally important for lots of programming things\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 2\na == 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\na < 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\na >= 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\na != 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nnumbers > 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE  TRUE  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nnumbers[numbers > 3] # filtering with equalities/inequalities\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6 5 4\n```\n\n\n:::\n:::\n\n\n### fancy operator bits\n\n::: {.cell}\n\n```{.r .cell-code}\n5 %% 3 # remainder / modulo for remainder-after-division\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\n5 %/% 3 # integer division\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n### core numeric functions\n\nNote that most of these functions are vectorised, but will require you to use `c()` if you want to supply your values directly (i.e. if you don't want to make a variable containing your values first). `sum()` is a rare exception:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(1,5,10) # works okay\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(c(1,5,10)) # but this works fine too, and is easy\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(c(1,5,10)) # and is the general way you'll need to work if you're supplying values directly to the function\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.333333\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(a) # square root\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.414214\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21\n```\n\n\n:::\n\n```{.r .cell-code}\ncumsum(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3  9 14 18 21\n```\n\n\n:::\n\n```{.r .cell-code}\nsqrt(numbers) # square roots\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.732051 2.449490 2.236068 2.000000 1.732051\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(numbers) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.2\n```\n\n\n:::\n\n```{.r .cell-code}\nmedian(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmin(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nmax(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\nFor odd reasons, there's no built-in function to find the statistical mode of some numbers. It can be done, but the code is ugly (and exactly the sort of thing we'd usually avoid in beginner's sessions). Included here for interest only:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# mode\nas.numeric(names(sort(-table(numbers)))[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\nThere are also a few other fairly basic functions that you might find helpful:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsd(numbers) # standard deviation\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.30384\n```\n\n\n:::\n\n```{.r .cell-code}\nrange(numbers) # min and max in one\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 6\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(numbers) # good for rapid numeric summaries\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n    3.0     3.0     4.0     4.2     5.0     6.0 \n```\n\n\n:::\n\n```{.r .cell-code}\ntable(numbers) # good for finding out what you've got in more complicated vectors\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnumbers\n3 4 5 6 \n2 1 1 1 \n```\n\n\n:::\n:::\n\n\n\n## interlude: joining code together\n\nThere are three main ways of doing this. Traditionally, you'd bracket together several functions, and read from the inside out. Fastest to write, hardest to read and fix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(sqrt(c(1,5,10)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\nor you can make intervening variables. Messy, but good if you need to be extra careful:\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- c(1,5,10)\no <- sqrt(n)\np <- round(o)\np\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\nor, probably the best way, pipe the code together. `Ctrl` + `Shift` + `m` will give you a pipe symbol:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1,5,10) |>\n  sqrt() |>\n  round()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\nNote that the pipe method doesn't automatically save your output. You'll need to assign with `<-` to do that:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp <- c(1,5,10) |>\n  sqrt() |>\n  round()\n\ntemp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\n## basic string functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntolower(hw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntoupper(hw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"HELLO WORLD\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntolower(longer_string)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"this\"      \"is\"        \"a\"         \"length\"    \"seven\"     \"character\"\n[7] \"vector\"   \n```\n\n\n:::\n\n```{.r .cell-code}\ntoupper(longer_string)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"THIS\"      \"IS\"        \"A\"         \"LENGTH\"    \"SEVEN\"     \"CHARACTER\"\n[7] \"VECTOR\"   \n```\n\n\n:::\n\n```{.r .cell-code}\npaste(hw, hw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello world hello world\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste(string, \"ed instrument\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"just a string ed instrument\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste0(\"question \", numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"question 3\" \"question 6\" \"question 5\" \"question 4\" \"question 3\"\n```\n\n\n:::\n\n```{.r .cell-code}\nrep(hw, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"hello world\" \"hello world\" \"hello world\" \"hello world\" \"hello world\"\n [6] \"hello world\" \"hello world\" \"hello world\" \"hello world\" \"hello world\"\n```\n\n\n:::\n:::\n\n\n## a few more interesting string functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstrsplit(hw, \" \") # split a string into pieces and get a list back\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"hello\" \"world\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstrsplit(hw, \" \") |> # split and unlist back to vector\n  unlist()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello\" \"world\"\n```\n\n\n:::\n\n```{.r .cell-code}\ngrep(\"seven\", longer_string) # tell me where in a vector a search term is found\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\ngrepl(\"seven\", longer_string) # tell me if a vector contains a search term\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nsort(longer_string) # into alphabetical order\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\"         \"character\" \"is\"        \"length\"    \"seven\"     \"this\"     \n[7] \"vector\"   \n```\n\n\n:::\n\n```{.r .cell-code}\ntable(longer_string) # as with numbers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlonger_string\n        a character        is    length     seven      this    vector \n        1         1         1         1         1         1         1 \n```\n\n\n:::\n:::\n\n\n# Session 3: functions, loops, and flow\n\nDon't repeat your code. Long code is hard to read and understand. Three basic design patterns: the function, the loop, the if/else.\n\n## write a function\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# basic function syntax\n# need to run the definition before calling it\n\nfunction_name <- function(argument){\n  # some code doing something to the argument\n  argument + 4 # the function will return the last value it produces\n}\n\nfunction_name(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# challenge - I'm bored of writing na.rm = TRUE. Could you make mean() automatically ignore the missing values?\n\nnew_mean <- function(x){\n  mean(x, na.rm = TRUE)\n}\n\nnew_mean(c(1,4,2,4,NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.75\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# arguments and defaults\n# simple function syntax without {}\n\nmulto <- function(n1, n2 = 7) n1 * n2\n\nmulto(3)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21\n```\n\n\n:::\n\n```{.r .cell-code}\nmulto(3, 6)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# anonymous function syntax is useful, but way too evil for a beginner's course\n\n(\\(x) x^2)(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 25\n```\n\n\n:::\n\n```{.r .cell-code}\n(\\(x, y) x^y)(5,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 125\n```\n\n\n:::\n:::\n\n\n## write a loop\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# basic syntax \nfor(i in 1:5){\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# seq_along as a sensible safe way to work with vectors\nfor(i in seq_along(numbers)){ # seq_along converts a vector into sequential integers 1,2,3,4... up to the length of the vector\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# indexing is the key to working with vectors inside loops\nfor(i in seq_along(numbers)){\n  print(numbers[i]) # with indexing\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n[1] 6\n[1] 5\n[1] 4\n[1] 3\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# need to create output first, then collect\n\nloop_output <- vector(mode = \"numeric\", length = length(numbers))\n\nfor(i in seq_along(numbers)){\n  loop_output[i] <- numbers[i] * 9 # insert each bit of output into the right place in the output vector\n}\n\nloop_output\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 27 54 45 36 27\n```\n\n\n:::\n:::\n\n\n## write an if/else\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# basic syntax\na <- 3\n\nif(a == 3){\n  \"a is three\"\n} else {\n  \"nope\"\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a is three\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# even easier if your condition is logical\nc <- TRUE\n\nif(c){\n  \"c is true\"\n} else {\n  \"nope\"\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"c is true\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# combine conditions\nb <- 2\n\nif(a == 3 | b == 3){\n  \"a and/or b are three\"\n} else {\n  \"nope\"\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a and/or b are three\"\n```\n\n\n:::\n\n```{.r .cell-code}\nif(a == 3 & b == 3){\n  \"a and/or b are three\"\n} else {\n  \"nope\"\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"nope\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- c(4,3)\n\nif(d == 3){\n  \"if/else isn't vectorised\"\n} else {\n  \"so this won't work\"\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# use the ifelse type if you need vectorised if/else\nd <- c(4,3)\n\nifelse(d == 3, \"...and we'll get this one second\", \"the first item is false, so we'll get this first\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"the first item is false, so we'll get this first\"\n[2] \"...and we'll get this one second\"                \n```\n\n\n:::\n:::\n\n::: \n<!--  the main tabset, so leave well alone and work within please -->\n\n\n",
    "supporting": [
      "r_from_scratch_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}